"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(home)/page",{

/***/ "(app-pages-browser)/./app/store/api/auth.ts":
/*!*******************************!*\
  !*** ./app/store/api/auth.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkCurrentPassword: () => (/* binding */ checkCurrentPassword),\n/* harmony export */   checkExistence: () => (/* binding */ checkExistence),\n/* harmony export */   fetchWithAuth: () => (/* binding */ fetchWithAuth),\n/* harmony export */   findUserId: () => (/* binding */ findUserId),\n/* harmony export */   getUserData: () => (/* binding */ getUserData),\n/* harmony export */   initiatePasswordReset: () => (/* binding */ initiatePasswordReset),\n/* harmony export */   joinUser: () => (/* binding */ joinUser),\n/* harmony export */   loginUser: () => (/* binding */ loginUser),\n/* harmony export */   resetUserPassword: () => (/* binding */ resetUserPassword),\n/* harmony export */   submitWithdrawSurvey: () => (/* binding */ submitWithdrawSurvey),\n/* harmony export */   updateUserProfile: () => (/* binding */ updateUserProfile),\n/* harmony export */   withdrawUser: () => (/* binding */ withdrawUser)\n/* harmony export */ });\n/* harmony import */ var js_cookie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! js-cookie */ \"(app-pages-browser)/./node_modules/js-cookie/dist/js.cookie.mjs\");\n\nconst API_BASE_URL = \"http://localhost:8080\";\n// Helper function for fetching with XSRF token and Authorization header\nconst fetchWithAuth = async function(url) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, retried = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    const xsrfToken = js_cookie__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get('XSRF-TOKEN');\n    const accessToken = js_cookie__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get('accessToken');\n    const headers = {\n        'Content-Type': 'application/json',\n        ...xsrfToken && {\n            'X-XSRF-TOKEN': xsrfToken\n        },\n        ...accessToken && {\n            Authorization: \"Bearer \".concat(accessToken)\n        },\n        ...options.headers\n    };\n    let response = await fetch(\"\".concat(API_BASE_URL).concat(url), {\n        ...options,\n        headers,\n        credentials: 'include'\n    });\n    // 401 Unauthorized 응답을 받았고, 아직 재시도하지 않은 경우\n    if (response.status === 401 && !retried) {\n        console.warn('액세스 토큰 만료 또는 유효하지 않음. 리프레시 토큰으로 재발급 시도.');\n        try {\n            // HttpOnly 리프레시 토큰은 브라우저가 자동으로 포함하여 백엔드로 전송합니다.\n            const refreshResponse = await fetch(\"\".concat(API_BASE_URL, \"/jwt/refresh\"), {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                // HttpOnly 리프레시 토큰은 브라우저가 'credentials: include' 설정에 따라 자동으로 쿠키에 포함하여 전송합니다.\n                credentials: 'include'\n            });\n            if (refreshResponse.ok) {\n                // 백엔드에서 Set-Cookie 헤더를 통해 새로운 Access Token (HttpOnly: false) 및 Refresh Token (HttpOnly: true)을 전달합니다.\n                // HttpOnly: false인 Access Token은 브라우저가 Set-Cookie 헤더를 통해 자동으로 처리하므로,\n                // 여기서 JSON 응답 본문을 파싱하여 localStorage에 따로 저장할 필요가 없습니다.\n                // 백엔드에서 HttpOnly: false로 Access Token을 설정한다면, 브라우저가 자동으로 Authorization 헤더에 추가할 수 있도록 관리합니다.\n                console.log('액세스 토큰 재발급 성공. 원래 요청을 재시도합니다.');\n                // 새로운 액세스 토큰으로 원래 요청을 재시도합니다. (retried 플래그 true)\n                response = await fetchWithAuth(url, options, true);\n            } else {\n                let errorData = {};\n                try {\n                    errorData = await refreshResponse.json();\n                } catch (e) {\n                    errorData.message = '리프레시 토큰 만료 또는 유효하지 않음.';\n                }\n                console.error('리프레시 토큰 재발급 실패:', errorData.message || '알 수 없는 오류');\n                throw new Error(errorData.message || '리프레시 토큰이 만료되었거나 유효하지 않습니다. 다시 로그인하십시오.');\n            }\n        } catch (error) {\n            console.error('토큰 재발급 중 오류 발생:', error);\n            throw error;\n        }\n    } else if (response.status === 401 && retried) {\n        let errorData = {};\n        try {\n            errorData = await response.json();\n        } catch (e) {\n            errorData.message = '액세스 토큰 재발급 후에도 인증되지 않았습니다.';\n        }\n        console.error('액세스 토큰 재발급 후에도 401 에러가 발생했습니다. 다시 로그인하십시오.');\n        throw new Error(errorData.message || '토큰 재발급 후에도 인증되지 않았습니다.');\n    }\n    // 최종 응답이 성공적이지 않으면 오류를 던집니다. (리프레시 토큰 처리 후)\n    if (!response.ok) {\n        let errorData = {};\n        try {\n            errorData = await response.json();\n        } catch (e) {\n            // JSON 파싱 실패 시, text()로 Fallback (백엔드 오류 메시지 예외 처리)\n            errorData.message = await response.text().catch(()=>'알 수 없는 오류');\n        }\n        const errorMessage = errorData.message || \"API 요청 실패: \".concat(response.status, \" \").concat(response.statusText);\n        // 사용자 명세에 따른 401, 403 에러 메시지 처리\n        if (response.status === 401) {\n            // 백엔드 명세: \"액세스 토큰이 없습니다. 로그인해주세요.\" 또는 \"액세스 토큰이 만료되었습니다. 다시 로그인해주세요.\"\n            if (errorMessage.includes(\"액세스 토큰이 없습니다.\") || errorMessage.includes(\"액세스 토큰이 만료되었습니다.\")) {\n                throw new Error(errorMessage);\n            }\n        } else if (response.status === 403) {\n            // 백엔드 명세: \"탈퇴한 회원입니다. 다시 로그인 해주세요.\"\n            if (errorMessage.includes(\"탈퇴한 회원입니다.\")) {\n                // 기존 localStorage에 남아있을 수 있는 accessToken 제거 (안전성 강화)\n                localStorage.removeItem('accessToken');\n                throw new Error('탈퇴한 회원입니다. 자동으로 로그아웃 처리됩니다.');\n            } else if (errorMessage.includes(\"비밀번호가 일치하지 않습니다.\")) {\n                throw new Error(errorMessage);\n            }\n        }\n        // 그 외 모든 오류는 그대로 던집니다.\n        throw new Error(errorMessage);\n    }\n    return response;\n};\n// 1. GET /user (사용자 정보 가져오기)\nconst getUserData = async ()=>{\n    const response = await fetchWithAuth('/user', {\n        method: 'GET'\n    });\n    return response.json();\n};\n// 2. POST /user/check-password (현재 비밀번호 확인)\nconst checkCurrentPassword = async (password)=>{\n    const response = await fetchWithAuth('/user/check-password', {\n        method: 'POST',\n        body: JSON.stringify({\n            password\n        })\n    });\n    const result = await response.json(); // API 명세에 따라 boolean 값 반환\n    return result;\n};\n// 3. PUT /user (사용자 정보 수정)\nconst updateUserProfile = async (data)=>{\n    const response = await fetchWithAuth('/user', {\n        method: 'PUT',\n        body: JSON.stringify(data)\n    });\n    return response.json();\n};\n// 4. POST /user/exist (아이디/이메일 중복 확인)\nconst checkExistence = async (field, value)=>{\n    try {\n        const apiPath = field === 'username' ? '/user/exist' : '/user/exist-email';\n        const response = await fetch(\"\".concat(API_BASE_URL).concat(apiPath), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                [field]: value\n            }),\n            credentials: 'include'\n        });\n        if (!response.ok) {\n            let errorData = {};\n            try {\n                errorData = await response.json();\n            } catch (e) {\n                errorData.message = response.statusText || '존재 여부 확인 실패: 서버 응답 오류';\n            }\n            // 백엔드 명세에 따라 409는 별도 메시지로 처리될 수 있음.\n            if (response.status === 409 || errorData.message && errorData.message.includes('이미 사용 중인 이메일입니다.')) {\n                return {\n                    isExist: true\n                };\n            }\n            throw new Error(errorData.message || '존재 여부 확인에 실패했습니다.');\n        }\n        // 오류를 던지지 않으면 중복이 아님\n        return {\n            isExist: false\n        };\n    } catch (error) {\n        // 기타 네트워크 오류 등은 여기서 처리\n        throw error;\n    }\n};\n// 5. POST /user (회원가입)\nconst joinUser = async (data)=>{\n    const response = await fetch(\"\".concat(API_BASE_URL, \"/user\"), {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(data),\n        credentials: 'include'\n    });\n    if (!response.ok) {\n        let errorData = {};\n        try {\n            errorData = await response.json();\n        } catch (e) {\n            errorData.message = response.statusText || '회원가입 실패: 서버 응답 오류';\n        }\n        throw new Error(errorData.message || '회원가입에 실패했습니다.');\n    }\n    return response.json();\n};\n// 6. POST /survey/withdraw (탈퇴 설문조사)\nconst submitWithdrawSurvey = async (data)=>{\n    const response = await fetchWithAuth('/survey/withdraw', {\n        method: 'POST',\n        body: JSON.stringify(data)\n    });\n    return response.text();\n};\n// 7. DELETE /user (회원 탈퇴)\nconst withdrawUser = async (data)=>{\n    const response = await fetchWithAuth('/user', {\n        method: 'DELETE',\n        body: JSON.stringify(data)\n    });\n    return response.text();\n};\n// 8. POST /user/find-id (아이디 찾기)\nconst findUserId = async (data)=>{\n    try {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/user/find-id\"), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(data),\n            credentials: 'include'\n        });\n        if (!response.ok) {\n            let errorData = {};\n            try {\n                errorData = await response.json();\n            } catch (e) {\n                errorData.message = response.statusText || '아이디 찾기 실패: 서버 응답 오류';\n            }\n            throw new Error(errorData.message || '아이디 찾기에 실패했습니다.');\n        }\n        return response.json();\n    } catch (error) {\n        // 백엔드 명세: 404 Not Found에 대해 특정 메시지\n        if (error.message.includes('가입 시 입력하신 회원 정보가 맞는지 다시 한번 확인해 주세요.')) {\n            throw new Error(error.message);\n        }\n        throw error;\n    }\n};\n// 9. POST /user/initiate-password-reset (비밀번호 재설정 시작)\nconst initiatePasswordReset = async (data)=>{\n    try {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/user/initiate-password-reset\"), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(data),\n            credentials: 'include'\n        });\n        if (!response.ok) {\n            let errorData = {};\n            try {\n                errorData = await response.json();\n            } catch (e) {\n                errorData.message = response.statusText || '비밀번호 재설정 시작 실패: 서버 응답 오류';\n            }\n            throw new Error(errorData.message || '비밀번호 재설정 시작에 실패했습니다.');\n        }\n        return response.json();\n    } catch (error) {\n        // 백엔드 명세: 404 Not Found에 대해 특정 메시지\n        if (error.message.includes('가입 시 입력하신 회원 정보가 맞는지 다시 한번 확인해 주세요.')) {\n            throw new Error(error.message);\n        }\n        throw error;\n    }\n};\n// 10. POST /user/reset-password (비밀번호 재설정 완료)\nconst resetUserPassword = async (data)=>{\n    try {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/user/reset-password\"), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(data),\n            credentials: 'include'\n        });\n        if (!response.ok) {\n            let errorData = {};\n            try {\n                errorData = await response.json();\n            } catch (e) {\n                errorData.message = response.statusText || '비밀번호 재설정 실패: 서버 응답 오류';\n            }\n            throw new Error(errorData.message || '비밀번호 재설정에 실패했습니다.');\n        }\n        return response.json();\n    } catch (error) {\n        // 백엔드 명세: 400 Bad Request에 대해 특정 메시지\n        if (error.message.includes('유효하지 않거나 만료된 토큰이거나, 비밀번호 정책에 맞지 않습니다.')) {\n            throw new Error(error.message);\n        }\n        throw error;\n    }\n};\n// 11. POST /login (로그인)\nconst loginUser = async (data)=>{\n    const response = await fetch(\"\".concat(API_BASE_URL, \"/login\"), {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(data),\n        credentials: 'include'\n    });\n    if (!response.ok) {\n        let errorData = {};\n        try {\n            errorData = await response.json();\n        } catch (e) {\n            errorData.message = response.statusText || '로그인 실패: 서버 응답 오류';\n        }\n        throw new Error(errorData.message || '로그인에 실패했습니다.');\n    }\n    return response.json();\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9zdG9yZS9hcGkvYXV0aC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQWdDO0FBZ0JoQyxNQUFNQyxlQUFlQyx1QkFBb0M7QUFFekQsd0VBQXdFO0FBQ2pFLE1BQU1HLGdCQUFnQixlQUFPQztRQUFhQywyRUFBdUIsQ0FBQyxHQUFHQywyRUFBVTtJQUNsRixNQUFNQyxZQUFZVCxpREFBT0EsQ0FBQ1UsR0FBRyxDQUFDO0lBQzlCLE1BQU1DLGNBQWNYLGlEQUFPQSxDQUFDVSxHQUFHLENBQUM7SUFFaEMsTUFBTUUsVUFBdUI7UUFDekIsZ0JBQWdCO1FBQ2hCLEdBQUlILGFBQWE7WUFBRSxnQkFBZ0JBO1FBQVUsQ0FBQztRQUM5QyxHQUFJRSxlQUFlO1lBQUVFLGVBQWUsVUFBc0IsT0FBWkY7UUFBYyxDQUFDO1FBQzdELEdBQUdKLFFBQVFLLE9BQU87SUFDdEI7SUFFQSxJQUFJRSxXQUFXLE1BQU1DLE1BQU0sR0FBa0JULE9BQWZMLGNBQW1CLE9BQUpLLE1BQU87UUFDaEQsR0FBR0MsT0FBTztRQUNWSztRQUNBSSxhQUFhO0lBQ2pCO0lBRUEsMkNBQTJDO0lBQzNDLElBQUlGLFNBQVNHLE1BQU0sS0FBSyxPQUFPLENBQUNULFNBQVM7UUFDckNVLFFBQVFDLElBQUksQ0FBQztRQUNiLElBQUk7WUFDQSxnREFBZ0Q7WUFDaEQsTUFBTUMsa0JBQWtCLE1BQU1MLE1BQU0sR0FBZ0IsT0FBYmQsY0FBYSxpQkFBZTtnQkFDL0RvQixRQUFRO2dCQUNSVCxTQUFTO29CQUNMLGdCQUFnQjtnQkFDcEI7Z0JBQ0EsNkVBQTZFO2dCQUM3RUksYUFBYTtZQUNqQjtZQUVBLElBQUlJLGdCQUFnQkUsRUFBRSxFQUFFO2dCQUNwQixzR0FBc0c7Z0JBQ3RHLHFFQUFxRTtnQkFDckUsc0RBQXNEO2dCQUN0RCw0RkFBNEY7Z0JBRTVGSixRQUFRSyxHQUFHLENBQUM7Z0JBQ1osaURBQWlEO2dCQUNqRFQsV0FBVyxNQUFNVCxjQUFj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QUVBLElBQUksQ0FBQ0YsU0FBU1EsRUFBRSxFQUFFO1lBQ2QsSUFBSUUsWUFBa0MsQ0FBQztZQUN2QyxJQUFJO2dCQUNBQSxZQUFZLE1BQU1WLFNBQVNXLElBQUk7WUFDbkMsRUFBRSxPQUFPQyxHQUFHO2dCQUNSRixVQUFVRyxPQUFPLEdBQUdiLFNBQVNtQixVQUFVLElBQUk7WUFDL0M7WUFDQSxNQUFNLElBQUlKLE1BQU1MLFVBQVVHLE9BQU8sSUFBSTtRQUN6QztRQUNBLE9BQU9iLFNBQVNXLElBQUk7SUFDeEIsRUFBRSxPQUFPRyxPQUFZO1FBQ2pCLHFDQUFxQztRQUNyQyxJQUFJQSxNQUFNRCxPQUFPLENBQUNPLFFBQVEsQ0FBQywwQ0FBMEM7WUFDakUsTUFBTSxJQUFJTCxNQUFNRCxNQUFNRCxPQUFPO1FBQ2pDO1FBQ0EsTUFBTUM7SUFDVjtBQUNKLEVBQUU7QUFFRix3QkFBd0I7QUFDakIsTUFBTTZCLFlBQVksT0FBT1o7SUFDNUIsTUFBTS9CLFdBQVcsTUFBTUMsTUFBTSxHQUFnQixPQUFiZCxjQUFhLFdBQVM7UUFDbERvQixRQUFRO1FBQ1JULFNBQVM7WUFDTCxnQkFBZ0I7UUFDcEI7UUFDQTRCLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQ0c7UUFDckI3QixhQUFhO0lBQ2pCO0lBRUEsSUFBSSxDQUFDRixTQUFTUSxFQUFFLEVBQUU7UUFDZCxJQUFJRSxZQUFrQyxDQUFDO1FBQ3ZDLElBQUk7WUFDQUEsWUFBWSxNQUFNVixTQUFTVyxJQUFJO1FBQ25DLEVBQUUsT0FBT0MsR0FBRztZQUNSRixVQUFVRyxPQUFPLEdBQUdiLFNBQVNtQixVQUFVLElBQUk7UUFDL0M7UUFDQSxNQUFNLElBQUlKLE1BQU1MLFVBQVVHLE9BQU8sSUFBSTtJQUN6QztJQUNBLE9BQU9iLFNBQVNXLElBQUk7QUFDeEIsRUFBRSIsInNvdXJjZXMiOlsiQzpcXFplcm9Nb2FcXEZyb250XFxhcHBcXHN0b3JlXFxhcGlcXGF1dGgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENvb2tpZXMgZnJvbSAnanMtY29va2llJztcbmltcG9ydCB7XG4gICAgVXNlclJlc3BvbnNlRFRPLFxuICAgIFVzZXJSZXF1ZXN0RFRPLFxuICAgIFdpdGhkcmF3U3VydmV5UmVxdWVzdERUTyxcbiAgICBVc2VyV2l0aGRyYXdSZXF1ZXN0RFRPLFxuICAgIENoZWNrRXhpc3RlbmNlUmVzcG9uc2UsXG4gICAgRmluZElkUmVxdWVzdCxcbiAgICBGaW5kSWRSZXNwb25zZSxcbiAgICBJbml0aWF0ZVBhc3N3b3JkUmVzZXRSZXF1ZXN0LFxuICAgIEluaXRpYXRlUGFzc3dvcmRSZXNldFJlc3BvbnNlLFxuICAgIFJlc2V0UGFzc3dvcmRSZXF1ZXN0LFxuICAgIExvZ2luUmVxdWVzdCxcbiAgICBMb2dpblJlc3BvbnNlXG59IGZyb20gJy4uLy4uLy4uL3R5cGVzL2F1dGgnO1xuXG5jb25zdCBBUElfQkFTRV9VUkwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfQkFTRV9VUkw7XG5cbi8vIEhlbHBlciBmdW5jdGlvbiBmb3IgZmV0Y2hpbmcgd2l0aCBYU1JGIHRva2VuIGFuZCBBdXRob3JpemF0aW9uIGhlYWRlclxuZXhwb3J0IGNvbnN0IGZldGNoV2l0aEF1dGggPSBhc3luYyAodXJsOiBzdHJpbmcsIG9wdGlvbnM6IFJlcXVlc3RJbml0ID0ge30sIHJldHJpZWQgPSBmYWxzZSk6IFByb21pc2U8UmVzcG9uc2U+ID0+IHtcbiAgICBjb25zdCB4c3JmVG9rZW4gPSBDb29raWVzLmdldCgnWFNSRi1UT0tFTicpO1xuICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gQ29va2llcy5nZXQoJ2FjY2Vzc1Rva2VuJyk7XG5cbiAgICBjb25zdCBoZWFkZXJzOiBIZWFkZXJzSW5pdCA9IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgLi4uKHhzcmZUb2tlbiAmJiB7ICdYLVhTUkYtVE9LRU4nOiB4c3JmVG9rZW4gfSksXG4gICAgICAgIC4uLihhY2Nlc3NUb2tlbiAmJiB7IEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHthY2Nlc3NUb2tlbn1gIH0pLFxuICAgICAgICAuLi5vcHRpb25zLmhlYWRlcnMsXG4gICAgfTtcblxuICAgIGxldCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0ke3VybH1gLCB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIGNyZWRlbnRpYWxzOiAnaW5jbHVkZScsIC8vIEh0dHBPbmx5IOumrO2UhOugiOyLnCDthqDtgbAg7J6Q64+ZIOyghOyGoeydhCDsnITtlbQg7Jyg7KeAXG4gICAgfSk7XG5cbiAgICAvLyA0MDEgVW5hdXRob3JpemVkIOydkeuLteydhCDrsJvslZjqs6AsIOyVhOyngSDsnqzsi5zrj4TtlZjsp4Ag7JWK7J2AIOqyveyasFxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMSAmJiAhcmV0cmllZCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ+yVoeyEuOyKpCDthqDtgbAg66eM66OMIOuYkOuKlCDsnKDtmqjtlZjsp4Ag7JWK7J2MLiDrpqztlITroIjsi5wg7Yag7YGw7Jy866GcIOyerOuwnOq4iSDsi5zrj4QuJyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBIdHRwT25seSDrpqztlITroIjsi5wg7Yag7YGw7J2AIOu4jOudvOyasOyggOqwgCDsnpDrj5nsnLzroZwg7Y+s7ZWo7ZWY7JesIOuwseyXlOuTnOuhnCDsoITshqHtlanri4jri6QuXG4gICAgICAgICAgICBjb25zdCByZWZyZXNoUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2p3dC9yZWZyZXNoYCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIEh0dHBPbmx5IOumrO2UhOugiOyLnCDthqDtgbDsnYAg67iM65287Jqw7KCA6rCAICdjcmVkZW50aWFsczogaW5jbHVkZScg7ISk7KCV7JeQIOuUsOudvCDsnpDrj5nsnLzroZwg7L+g7YKk7JeQIO2PrO2VqO2VmOyXrCDsoITshqHtlanri4jri6QuXG4gICAgICAgICAgICAgICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJyxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAocmVmcmVzaFJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgLy8g67Cx7JeU65Oc7JeQ7IScIFNldC1Db29raWUg7Zek642U66W8IO2Gte2VtCDsg4jroZzsmrQgQWNjZXNzIFRva2VuIChIdHRwT25seTogZmFsc2UpIOuwjyBSZWZyZXNoIFRva2VuIChIdHRwT25seTogdHJ1ZSnsnYQg7KCE64us7ZWp64uI64ukLlxuICAgICAgICAgICAgICAgIC8vIEh0dHBPbmx5OiBmYWxzZeyduCBBY2Nlc3MgVG9rZW7snYAg67iM65287Jqw7KCA6rCAIFNldC1Db29raWUg7Zek642U66W8IO2Gte2VtCDsnpDrj5nsnLzroZwg7LKY66as7ZWY66+A66GcLFxuICAgICAgICAgICAgICAgIC8vIOyXrOq4sOyEnCBKU09OIOydkeuLtSDrs7jrrLjsnYQg7YyM7Iux7ZWY7JesIGxvY2FsU3RvcmFnZeyXkCDrlLDroZwg7KCA7J6l7ZWgIO2VhOyalOqwgCDsl4bsirXri4jri6QuXG4gICAgICAgICAgICAgICAgLy8g67Cx7JeU65Oc7JeQ7IScIEh0dHBPbmx5OiBmYWxzZeuhnCBBY2Nlc3MgVG9rZW7snYQg7ISk7KCV7ZWc64uk66m0LCDruIzrnbzsmrDsoIDqsIAg7J6Q64+Z7Jy866GcIEF1dGhvcml6YXRpb24g7Zek642U7JeQIOy2lOqwgO2VoCDsiJgg7J6I64+E66GdIOq0gOumrO2VqeuLiOuLpC5cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygn7JWh7IS47IqkIO2GoO2BsCDsnqzrsJzquIkg7ISx6rO1LiDsm5Drnpgg7JqU7LKt7J2EIOyerOyLnOuPhO2VqeuLiOuLpC4nKTtcbiAgICAgICAgICAgICAgICAvLyDsg4jroZzsmrQg7JWh7IS47IqkIO2GoO2BsOycvOuhnCDsm5Drnpgg7JqU7LKt7J2EIOyerOyLnOuPhO2VqeuLiOuLpC4gKHJldHJpZWQg7ZSM656Y6re4IHRydWUpXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhBdXRoKHVybCwgb3B0aW9ucywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBlcnJvckRhdGE6IHsgbWVzc2FnZT86IHN0cmluZyB9ID0ge307XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JEYXRhID0gYXdhaXQgcmVmcmVzaFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yRGF0YS5tZXNzYWdlID0gJ+umrO2UhOugiOyLnCDthqDtgbAg66eM66OMIOuYkOuKlCDsnKDtmqjtlZjsp4Ag7JWK7J2MLic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ+umrO2UhOugiOyLnCDthqDtgbAg7J6s67Cc6riJIOyLpO2MqDonLCBlcnJvckRhdGEubWVzc2FnZSB8fCAn7JWMIOyImCDsl4bripQg7Jik66WYJyk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8ICfrpqztlITroIjsi5wg7Yag7YGw7J20IOunjOujjOuQmOyXiOqxsOuCmCDsnKDtmqjtlZjsp4Ag7JWK7Iq164uI64ukLiDri6Tsi5wg66Gc6re47J247ZWY7Iut7Iuc7JikLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcign7Yag7YGwIOyerOuwnOq4iSDspJEg7Jik66WYIOuwnOyDnTonLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDEgJiYgcmV0cmllZCkge1xuICAgICAgICBsZXQgZXJyb3JEYXRhOiB7IG1lc3NhZ2U/OiBzdHJpbmcgfSA9IHt9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBlcnJvckRhdGEubWVzc2FnZSA9ICfslaHshLjsiqQg7Yag7YGwIOyerOuwnOq4iSDtm4Tsl5Drj4Qg7J247Kad65CY7KeAIOyViuyVmOyKteuLiOuLpC4nO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+yVoeyEuOyKpCDthqDtgbAg7J6s67Cc6riJIO2bhOyXkOuPhCA0MDEg7JeQ65+s6rCAIOuwnOyDne2WiOyKteuLiOuLpC4g64uk7IucIOuhnOq3uOyduO2VmOyLreyLnOyYpC4nKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8ICfthqDtgbAg7J6s67Cc6riJIO2bhOyXkOuPhCDsnbjspp3rkJjsp4Ag7JWK7JWY7Iq164uI64ukLicpO1xuICAgIH1cblxuICAgIC8vIOy1nOyihSDsnZHri7XsnbQg7ISx6rO17KCB7J207KeAIOyViuycvOuptCDsmKTrpZjrpbwg642Y7KeR64uI64ukLiAo66as7ZSE66CI7IucIO2GoO2BsCDsspjrpqwg7ZuEKVxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgbGV0IGVycm9yRGF0YTogeyBtZXNzYWdlPzogc3RyaW5nLCBzdGF0dXM/OiBzdHJpbmcgfSA9IHt9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBKU09OIO2MjOyLsSDsi6TtjKgg7IucLCB0ZXh0KCnroZwgRmFsbGJhY2sgKOuwseyXlOuTnCDsmKTrpZgg66mU7Iuc7KeAIOyYiOyZuCDsspjrpqwpXG4gICAgICAgICAgICBlcnJvckRhdGEubWVzc2FnZSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKS5jYXRjaCgoKSA9PiAn7JWMIOyImCDsl4bripQg7Jik66WYJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvckRhdGEubWVzc2FnZSB8fCBgQVBJIOyalOyyrSDsi6TtjKg6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YDtcblxuICAgICAgICAvLyDsgqzsmqnsnpAg66qF7IS47JeQIOuUsOuluCA0MDEsIDQwMyDsl5Drn6wg66mU7Iuc7KeAIOyymOumrFxuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDEpIHtcbiAgICAgICAgICAgIC8vIOuwseyXlOuTnCDrqoXshLg6IFwi7JWh7IS47IqkIO2GoO2BsOydtCDsl4bsirXri4jri6QuIOuhnOq3uOyduO2VtOyjvOyEuOyalC5cIiDrmJDripQgXCLslaHshLjsiqQg7Yag7YGw7J20IOunjOujjOuQmOyXiOyKteuLiOuLpC4g64uk7IucIOuhnOq3uOyduO2VtOyjvOyEuOyalC5cIlxuICAgICAgICAgICAgaWYgKGVycm9yTWVzc2FnZS5pbmNsdWRlcyhcIuyVoeyEuOyKpCDthqDtgbDsnbQg7JeG7Iq164uI64ukLlwiKSB8fCBlcnJvck1lc3NhZ2UuaW5jbHVkZXMoXCLslaHshLjsiqQg7Yag7YGw7J20IOunjOujjOuQmOyXiOyKteuLiOuLpC5cIikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMykge1xuICAgICAgICAgICAgLy8g67Cx7JeU65OcIOuqheyEuDogXCLtg4jth7TtlZwg7ZqM7JuQ7J6F64uI64ukLiDri6Tsi5wg66Gc6re47J24IO2VtOyjvOyEuOyalC5cIlxuICAgICAgICAgICAgaWYgKGVycm9yTWVzc2FnZS5pbmNsdWRlcyhcIu2DiO2HtO2VnCDtmozsm5DsnoXri4jri6QuXCIpKSB7XG4gICAgICAgICAgICAgICAgLy8g6riw7KG0IGxvY2FsU3RvcmFnZeyXkCDrgqjslYTsnojsnYQg7IiYIOyeiOuKlCBhY2Nlc3NUb2tlbiDsoJzqsbAgKOyViOyghOyEsSDqsJXtmZQpXG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2FjY2Vzc1Rva2VuJyk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCftg4jth7TtlZwg7ZqM7JuQ7J6F64uI64ukLiDsnpDrj5nsnLzroZwg66Gc6re47JWE7JuDIOyymOumrOuQqeuLiOuLpC4nKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3JNZXNzYWdlLmluY2x1ZGVzKFwi67mE67CA67KI7Zi46rCAIOydvOy5mO2VmOyngCDslYrsirXri4jri6QuXCIpKSB7IC8vIO2ajOybkCDtg4jth7Qg7IucIOuwnOyDne2VoCDsiJgg7J6I64qUIDQwM1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIOq3uCDsmbgg66qo65OgIOyYpOulmOuKlCDqt7jrjIDroZwg642Y7KeR64uI64ukLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG59O1xuXG4vLyAxLiBHRVQgL3VzZXIgKOyCrOyaqeyekCDsoJXrs7Qg6rCA7KC47Jik6riwKVxuZXhwb3J0IGNvbnN0IGdldFVzZXJEYXRhID0gYXN5bmMgKCk6IFByb21pc2U8VXNlclJlc3BvbnNlRFRPPiA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhBdXRoKCcvdXNlcicsIHsgbWV0aG9kOiAnR0VUJyB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xufTtcblxuLy8gMi4gUE9TVCAvdXNlci9jaGVjay1wYXNzd29yZCAo7ZiE7J6sIOu5hOuwgOuyiO2YuCDtmZXsnbgpXG5leHBvcnQgY29uc3QgY2hlY2tDdXJyZW50UGFzc3dvcmQgPSBhc3luYyAocGFzc3dvcmQ6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hXaXRoQXV0aCgnL3VzZXIvY2hlY2stcGFzc3dvcmQnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHBhc3N3b3JkIH0pLFxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTsgLy8gQVBJIOuqheyEuOyXkCDrlLDrnbwgYm9vbGVhbiDqsJIg67CY7ZmYXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIDMuIFBVVCAvdXNlciAo7IKs7Jqp7J6QIOygleuztCDsiJjsoJUpXG5leHBvcnQgY29uc3QgdXBkYXRlVXNlclByb2ZpbGUgPSBhc3luYyAoZGF0YTogVXNlclJlcXVlc3REVE8pOiBQcm9taXNlPFVzZXJSZXNwb25zZURUTz4gPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hXaXRoQXV0aCgnL3VzZXInLCB7XG4gICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG59O1xuXG4vLyA0LiBQT1NUIC91c2VyL2V4aXN0ICjslYTsnbTrlJQv7J2066mU7J28IOykkeuztSDtmZXsnbgpXG5leHBvcnQgY29uc3QgY2hlY2tFeGlzdGVuY2UgPSBhc3luYyAoZmllbGQ6ICd1c2VybmFtZScgfCAnZW1haWwnLCB2YWx1ZTogc3RyaW5nKTogUHJvbWlzZTxDaGVja0V4aXN0ZW5jZVJlc3BvbnNlPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9IGZpZWxkID09PSAndXNlcm5hbWUnID8gJy91c2VyL2V4aXN0JyA6ICcvdXNlci9leGlzdC1lbWFpbCc7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfSR7YXBpUGF0aH1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgW2ZpZWxkXTogdmFsdWUgfSksXG4gICAgICAgICAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnLFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICBsZXQgZXJyb3JEYXRhOiB7IG1lc3NhZ2U/OiBzdHJpbmcgfSA9IHt9O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JEYXRhLm1lc3NhZ2UgPSByZXNwb25zZS5zdGF0dXNUZXh0IHx8ICfsobTsnqwg7Jes67aAIO2ZleyduCDsi6TtjKg6IOyEnOuyhCDsnZHri7Ug7Jik66WYJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIOuwseyXlOuTnCDrqoXshLjsl5Ag65Sw6528IDQwOeuKlCDrs4Trj4Qg66mU7Iuc7KeA66GcIOyymOumrOuQoCDsiJgg7J6I7J2MLlxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA5IHx8IChlcnJvckRhdGEubWVzc2FnZSAmJiBlcnJvckRhdGEubWVzc2FnZS5pbmNsdWRlcygn7J2066+4IOyCrOyaqSDspJHsnbgg7J2066mU7J287J6F64uI64ukLicpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGlzRXhpc3Q6IHRydWUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEubWVzc2FnZSB8fCAn7KG07J6sIOyXrOu2gCDtmZXsnbjsl5Ag7Iuk7Yyo7ZaI7Iq164uI64ukLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIOyYpOulmOulvCDrjZjsp4Dsp4Ag7JWK7Jy866m0IOykkeuzteydtCDslYTri5hcbiAgICAgICAgcmV0dXJuIHsgaXNFeGlzdDogZmFsc2UgfTtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIC8vIOq4sO2DgCDrhKTtirjsm4ztgawg7Jik66WYIOuTseydgCDsl6zquLDshJwg7LKY66asXG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn07XG5cbi8vIDUuIFBPU1QgL3VzZXIgKO2ajOybkOqwgOyehSlcbmV4cG9ydCBjb25zdCBqb2luVXNlciA9IGFzeW5jIChkYXRhOiBVc2VyUmVxdWVzdERUTyk6IFByb21pc2U8YW55PiA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L3VzZXJgLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJyxcbiAgICB9KTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgbGV0IGVycm9yRGF0YTogeyBtZXNzYWdlPzogc3RyaW5nIH0gPSB7fTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyb3JEYXRhLm1lc3NhZ2UgPSByZXNwb25zZS5zdGF0dXNUZXh0IHx8ICftmozsm5DqsIDsnoUg7Iuk7YyoOiDshJzrsoQg7J2R64u1IOyYpOulmCc7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8ICftmozsm5DqsIDsnoXsl5Ag7Iuk7Yyo7ZaI7Iq164uI64ukLicpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xufTtcblxuLy8gNi4gUE9TVCAvc3VydmV5L3dpdGhkcmF3ICjtg4jth7Qg7ISk66y47KGw7IKsKVxuZXhwb3J0IGNvbnN0IHN1Ym1pdFdpdGhkcmF3U3VydmV5ID0gYXN5bmMgKGRhdGE6IFdpdGhkcmF3U3VydmV5UmVxdWVzdERUTyk6IFByb21pc2U8c3RyaW5nPiA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhBdXRoKCcvc3VydmV5L3dpdGhkcmF3Jywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbn07XG5cbi8vIDcuIERFTEVURSAvdXNlciAo7ZqM7JuQIO2DiO2HtClcbmV4cG9ydCBjb25zdCB3aXRoZHJhd1VzZXIgPSBhc3luYyAoZGF0YTogVXNlcldpdGhkcmF3UmVxdWVzdERUTyk6IFByb21pc2U8c3RyaW5nPiA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhBdXRoKCcvdXNlcicsIHtcbiAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbn07XG5cbi8vIDguIFBPU1QgL3VzZXIvZmluZC1pZCAo7JWE7J2065SUIOywvuq4sClcbmV4cG9ydCBjb25zdCBmaW5kVXNlcklkID0gYXN5bmMgKGRhdGE6IEZpbmRJZFJlcXVlc3QpOiBQcm9taXNlPEZpbmRJZFJlc3BvbnNlPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L3VzZXIvZmluZC1pZGAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgICAgICAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnLFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICBsZXQgZXJyb3JEYXRhOiB7IG1lc3NhZ2U/OiBzdHJpbmcgfSA9IHt9O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JEYXRhLm1lc3NhZ2UgPSByZXNwb25zZS5zdGF0dXNUZXh0IHx8ICfslYTsnbTrlJQg7LC+6riwIOyLpO2MqDog7ISc67KEIOydkeuLtSDsmKTrpZgnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8ICfslYTsnbTrlJQg7LC+6riw7JeQIOyLpO2MqO2WiOyKteuLiOuLpC4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgLy8g67Cx7JeU65OcIOuqheyEuDogNDA0IE5vdCBGb3VuZOyXkCDrjIDtlbQg7Yq57KCVIOuplOyLnOyngFxuICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcygn6rCA7J6FIOyLnCDsnoXroKXtlZjsi6Ag7ZqM7JuQIOygleuztOqwgCDrp57ripTsp4Ag64uk7IucIO2VnOuyiCDtmZXsnbjtlbQg7KO87IS47JqULicpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufTtcblxuLy8gOS4gUE9TVCAvdXNlci9pbml0aWF0ZS1wYXNzd29yZC1yZXNldCAo67mE67CA67KI7Zi4IOyerOyEpOyglSDsi5zsnpEpXG5leHBvcnQgY29uc3QgaW5pdGlhdGVQYXNzd29yZFJlc2V0ID0gYXN5bmMgKGRhdGE6IEluaXRpYXRlUGFzc3dvcmRSZXNldFJlcXVlc3QpOiBQcm9taXNlPEluaXRpYXRlUGFzc3dvcmRSZXNldFJlc3BvbnNlPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L3VzZXIvaW5pdGlhdGUtcGFzc3dvcmQtcmVzZXRgLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgICAgICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgbGV0IGVycm9yRGF0YTogeyBtZXNzYWdlPzogc3RyaW5nIH0gPSB7fTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGVycm9yRGF0YS5tZXNzYWdlID0gcmVzcG9uc2Uuc3RhdHVzVGV4dCB8fCAn67mE67CA67KI7Zi4IOyerOyEpOyglSDsi5zsnpEg7Iuk7YyoOiDshJzrsoQg7J2R64u1IOyYpOulmCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgJ+u5hOuwgOuyiO2YuCDsnqzshKTsoJUg7Iuc7J6R7JeQIOyLpO2MqO2WiOyKteuLiOuLpC4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgLy8g67Cx7JeU65OcIOuqheyEuDogNDA0IE5vdCBGb3VuZOyXkCDrjIDtlbQg7Yq57KCVIOuplOyLnOyngFxuICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcygn6rCA7J6FIOyLnCDsnoXroKXtlZjsi6Ag7ZqM7JuQIOygleuztOqwgCDrp57ripTsp4Ag64uk7IucIO2VnOuyiCDtmZXsnbjtlbQg7KO87IS47JqULicpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufTtcblxuLy8gMTAuIFBPU1QgL3VzZXIvcmVzZXQtcGFzc3dvcmQgKOu5hOuwgOuyiO2YuCDsnqzshKTsoJUg7JmE66OMKVxuZXhwb3J0IGNvbnN0IHJlc2V0VXNlclBhc3N3b3JkID0gYXN5bmMgKGRhdGE6IFJlc2V0UGFzc3dvcmRSZXF1ZXN0KTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vdXNlci9yZXNldC1wYXNzd29yZGAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgICAgICAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnLFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICBsZXQgZXJyb3JEYXRhOiB7IG1lc3NhZ2U/OiBzdHJpbmcgfSA9IHt9O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JEYXRhLm1lc3NhZ2UgPSByZXNwb25zZS5zdGF0dXNUZXh0IHx8ICfruYTrsIDrsojtmLgg7J6s7ISk7KCVIOyLpO2MqDog7ISc67KEIOydkeuLtSDsmKTrpZgnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8ICfruYTrsIDrsojtmLgg7J6s7ISk7KCV7JeQIOyLpO2MqO2WiOyKteuLiOuLpC4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgLy8g67Cx7JeU65OcIOuqheyEuDogNDAwIEJhZCBSZXF1ZXN07JeQIOuMgO2VtCDtirnsoJUg66mU7Iuc7KeAXG4gICAgICAgIGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCfsnKDtmqjtlZjsp4Ag7JWK6rGw64KYIOunjOujjOuQnCDthqDtgbDsnbTqsbDrgpgsIOu5hOuwgOuyiO2YuCDsoJXssYXsl5Ag66ee7KeAIOyViuyKteuLiOuLpC4nKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn07XG5cbi8vIDExLiBQT1NUIC9sb2dpbiAo66Gc6re47J24KVxuZXhwb3J0IGNvbnN0IGxvZ2luVXNlciA9IGFzeW5jIChkYXRhOiBMb2dpblJlcXVlc3QpOiBQcm9taXNlPExvZ2luUmVzcG9uc2U+ID0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vbG9naW5gLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJyxcbiAgICB9KTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgbGV0IGVycm9yRGF0YTogeyBtZXNzYWdlPzogc3RyaW5nIH0gPSB7fTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyb3JEYXRhLm1lc3NhZ2UgPSByZXNwb25zZS5zdGF0dXNUZXh0IHx8ICfroZzqt7jsnbgg7Iuk7YyoOiDshJzrsoQg7J2R64u1IOyYpOulmCc7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlIHx8ICfroZzqt7jsnbjsl5Ag7Iuk7Yyo7ZaI7Iq164uI64ukLicpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xufTtcbiJdLCJuYW1lcyI6WyJDb29raWVzIiwiQVBJX0JBU0VfVVJMIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9CQVNFX1VSTCIsImZldGNoV2l0aEF1dGgiLCJ1cmwiLCJvcHRpb25zIiwicmV0cmllZCIsInhzcmZUb2tlbiIsImdldCIsImFjY2Vzc1Rva2VuIiwiaGVhZGVycyIsIkF1dGhvcml6YXRpb24iLCJyZXNwb25zZSIsImZldGNoIiwiY3JlZGVudGlhbHMiLCJzdGF0dXMiLCJjb25zb2xlIiwid2FybiIsInJlZnJlc2hSZXNwb25zZSIsIm1ldGhvZCIsIm9rIiwibG9nIiwiZXJyb3JEYXRhIiwianNvbiIsImUiLCJtZXNzYWdlIiwiZXJyb3IiLCJFcnJvciIsInRleHQiLCJjYXRjaCIsImVycm9yTWVzc2FnZSIsInN0YXR1c1RleHQiLCJpbmNsdWRlcyIsImxvY2FsU3RvcmFnZSIsInJlbW92ZUl0ZW0iLCJnZXRVc2VyRGF0YSIsImNoZWNrQ3VycmVudFBhc3N3b3JkIiwicGFzc3dvcmQiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInJlc3VsdCIsInVwZGF0ZVVzZXJQcm9maWxlIiwiZGF0YSIsImNoZWNrRXhpc3RlbmNlIiwiZmllbGQiLCJ2YWx1ZSIsImFwaVBhdGgiLCJpc0V4aXN0Iiwiam9pblVzZXIiLCJzdWJtaXRXaXRoZHJhd1N1cnZleSIsIndpdGhkcmF3VXNlciIsImZpbmRVc2VySWQiLCJpbml0aWF0ZVBhc3N3b3JkUmVzZXQiLCJyZXNldFVzZXJQYXNzd29yZCIsImxvZ2luVXNlciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/store/api/auth.ts\n"));

/***/ })

});